name: üöÄ Terraform + Docker CI/CD to EC2

on:
  push:
    branches: [ "main" ]
    paths:
      - 'terraform/**'
      - 'Dockerfile'
      - '**/*.py'
      - '**/*.js'
      - '**/*.yml'

jobs:
  deploy:
    runs-on: ubuntu-latest
    env:
      AWS_REGION: eu-north-1
      ECR_REPO_NAME: my-simple-app
      IMAGE_TAG: latest
      APP_PORT: 8090

    steps:
      # 1Ô∏è‚É£ Checkout code
      - name: üß© Checkout repository
        uses: actions/checkout@v4

      # 2Ô∏è‚É£ Setup Terraform
      - name: ‚öôÔ∏è Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.5.7

      # 3Ô∏è‚É£ Configure AWS credentials
      - name: üîë Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      # 4Ô∏è‚É£ Terraform init
      - name: üèóÔ∏è Terraform Init
        working-directory: terraform
        run: terraform init

      # 5Ô∏è‚É£ Terraform apply (create EC2, SG, Key Pair)
      - name: üå± Terraform Apply
        working-directory: terraform
        run: terraform apply -auto-approve

      # 6Ô∏è‚É£ Get EC2 public IP from Terraform output
      - name: üåê Get EC2 Public IP
        id: ec2_ip
        working-directory: terraform
        run: |
          echo "EC2_PUBLIC_IP=$(terraform output -raw ec2_public_ip)" >> $GITHUB_ENV

      # 7Ô∏è‚É£ Log in to ECR
      - name: üê≥ Log in to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      # 8Ô∏è‚É£ Ensure ECR repository exists
      - name: üèóÔ∏è Ensure ECR Repository Exists
        run: |
          aws ecr describe-repositories --repository-names ${{ env.ECR_REPO_NAME }} --region ${{ env.AWS_REGION }} || \
          aws ecr create-repository --repository-name ${{ env.ECR_REPO_NAME }} --region ${{ env.AWS_REGION }}

      # 9Ô∏è‚É£ Build, tag, and push Docker image
      - name: üß± Build, Tag, and Push Docker Image
        run: |
          IMAGE_URI=${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPO_NAME }}:${{ env.IMAGE_TAG }}
          echo "Building image: $IMAGE_URI"
          docker build -t $IMAGE_URI .
          docker push $IMAGE_URI
          echo "IMAGE_URI=$IMAGE_URI" >> $GITHUB_ENV

      # üîü SSH into EC2 and deploy Docker container
      - name: üöÄ Deploy Docker on EC2
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ env.EC2_PUBLIC_IP }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: 22
          script_stop: true
          command_timeout: 30m
          script: |
            echo "‚úÖ Connected to EC2"

            # Install Docker if missing
            if ! command -v docker &> /dev/null; then
              sudo dnf install -y docker
            fi
            sudo systemctl enable docker
            sudo systemctl start docker

            # Log in to ECR
            aws ecr get-login-password --region ${{ env.AWS_REGION }} | sudo docker login --username AWS --password-stdin ${{ steps.login-ecr.outputs.registry }}

            # Pull and run Docker container
            docker pull ${{ env.IMAGE_URI }}
            docker stop my-simple-app || true
            docker rm my-simple-app || true
            docker run -d -p ${{ env.APP_PORT }}:${{ env.APP_PORT }} --name my-simple-app --restart always ${{ env.IMAGE_URI }}

            echo "‚úÖ Docker container deployed and running!"

      # 1Ô∏è‚É£1Ô∏è‚É£ Show live app URL with retries
      - name: üåç Show live app URL
        run: |
          APP_URL="http://${{ env.EC2_PUBLIC_IP }}:${{ env.APP_PORT }}"
          echo "üéâ Your app should be live at: $APP_URL"

          # Retry loop (max 10 attempts, 5s interval)
          MAX_RETRIES=10
          SLEEP_TIME=5
          SUCCESS=0

          for i in $(seq 1 $MAX_RETRIES); do
            STATUS=$(curl -s -o /dev/null -w "%{http_code}" $APP_URL || echo "000")
            if [ "$STATUS" -eq 200 ]; then
              echo "‚úÖ App is responding (HTTP 200) after $i attempts!"
              SUCCESS=1
              break
            else
              echo "‚è≥ Attempt $i: App not ready (HTTP $STATUS), retrying in $SLEEP_TIME seconds..."
              sleep $SLEEP_TIME
            fi
          done

          if [ "$SUCCESS" -ne 1 ]; then
            echo "‚ö†Ô∏è App did not respond after $MAX_RETRIES attempts."
            exit 1
          fi
