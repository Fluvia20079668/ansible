name: ğŸš€ Terraform + Docker CI/CD

on:
  push:
    branches: [ "main" ]
    paths:
      - 'terraform/**'
      - 'Dockerfile'
      - '**/*.py'
      - '**/*.js'
      - '**/*.yml'

jobs:
  deploy:
    runs-on: ubuntu-latest
    env:
      AWS_REGION: eu-north-1
      ECR_REPO_NAME: my-simple-app
      IMAGE_TAG: latest

    steps:
      # 1ï¸âƒ£ Checkout repo
      - name: ğŸ§© Checkout repository
        uses: actions/checkout@v4

      # 2ï¸âƒ£ Configure AWS credentials
      - name: ğŸ”‘ Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      # 3ï¸âƒ£ Setup Terraform
      - name: ğŸ› ï¸ Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.5.0

      # 4ï¸âƒ£ Terraform init
      - name: â›ï¸ Terraform Init
        working-directory: terraform
        run: terraform init

      # 5ï¸âƒ£ Terraform apply
      - name: ğŸŒ Terraform Apply
        working-directory: terraform
        run: terraform apply -auto-approve

      # 6ï¸âƒ£ Get Terraform outputs safely
      - name: ğŸ“¡ Get Terraform outputs
        working-directory: terraform
        id: tf_outputs
        run: |
          # Extract outputs using JSON to avoid debug metadata
          EC2_PUBLIC_IP=$(terraform output -json ec2_public_ip | jq -r '.')
          ECR_URI=$(terraform output -json ecr_repository_uri | jq -r '.')
          PRIVATE_KEY_PEM=$(terraform output -raw private_key_pem)

          # Validate outputs
          if [ -z "$EC2_PUBLIC_IP" ] || [ -z "$ECR_URI" ]; then
            echo "âŒ Terraform outputs missing!"
            exit 1
          fi

          # Save variables to GitHub environment
          echo "EC2_PUBLIC_IP=$EC2_PUBLIC_IP" >> $GITHUB_ENV
          echo "ECR_URI=$ECR_URI" >> $GITHUB_ENV

          # Save private key for SSH
          echo "$PRIVATE_KEY_PEM" > deploy_key.pem
          chmod 600 deploy_key.pem

      # 7ï¸âƒ£ Log in to ECR
      - name: ğŸ³ Docker Login to ECR
        run: |
          echo "Logging into ECR: $ECR_URI"
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin $ECR_URI

      # 8ï¸âƒ£ Build, tag, and push Docker image
      - name: ğŸ§± Build and Push Docker Image
        run: |
          IMAGE_URI=$ECR_URI:$IMAGE_TAG
          echo "Building Docker image: $IMAGE_URI"
          docker build -t $IMAGE_URI .
          docker push $IMAGE_URI
          echo "IMAGE_URI=$IMAGE_URI" >> $GITHUB_ENV

      # 9ï¸âƒ£ Deploy Docker container on EC2
      - name: ğŸš€ Deploy Docker on EC2
        run: |
          ssh -o StrictHostKeyChecking=no -i deploy_key.pem ec2-user@$EC2_PUBLIC_IP << EOF
            sudo yum install -y docker awscli
            sudo systemctl enable docker
            sudo systemctl start docker
            aws ecr get-login-password --region ${{ env.AWS_REGION }} | sudo docker login --username AWS --password-stdin $ECR_URI
            sudo docker stop my-app || true
            sudo docker rm my-app || true
            sudo docker run -d -p 8090:8090 --name my-app --restart always $IMAGE_URI
          EOF

      # ğŸ”Ÿ Display live app URL
      - name: ğŸŒ App URL
        run: echo "âœ… Your app is live at http://$EC2_PUBLIC_IP:8090"
