name: ðŸš€ Terraform + Docker CI/CD

on:
  push:
    branches: [ "main" ]
    paths:
      - 'terraform/**'
      - 'Dockerfile'
      - '**/*.py'
      - '**/*.js'
      - '**/*.yml'

jobs:
  deploy:
    runs-on: ubuntu-latest
    env:
      AWS_REGION: eu-north-1
      ECR_REPO_NAME: my-simple-app
      IMAGE_TAG: latest

    steps:
      # 1ï¸âƒ£ Checkout repo
      - name: ðŸ§© Checkout repository
        uses: actions/checkout@v4

      # 2ï¸âƒ£ Configure AWS credentials
      - name: ðŸ”‘ Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      # 3ï¸âƒ£ Install Terraform
      - name: ðŸ› ï¸ Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.5.0

      # 4ï¸âƒ£ Initialize Terraform
      - name: â›ï¸ Terraform Init
        working-directory: terraform
        run: terraform init

      # 5ï¸âƒ£ Apply Terraform (auto-approve)
      - name: ðŸŒ Terraform Apply
        working-directory: terraform
        run: terraform apply -auto-approve

      # 6ï¸âƒ£ Extract Terraform outputs safely
      - name: ðŸ“¡ Get Terraform outputs
        working-directory: terraform
        id: tf_outputs
        run: |
          # Save outputs to temporary files
          terraform output -raw ec2_public_ip > ec2_ip.txt
          terraform output -raw ecr_repository_uri > ecr_uri.txt
          terraform output -raw private_key_pem > private_key.pem

          # Clean whitespace
          EC2_PUBLIC_IP=$(cat ec2_ip.txt | tr -d '[:space:]')
          ECR_URI=$(cat ecr_uri.txt | tr -d '[:space:]')

          # Base64 encode private key to handle multi-line safely
          PRIVATE_KEY_B64=$(base64 -w 0 private_key.pem)

          # Write clean variables to GitHub env
          echo "EC2_PUBLIC_IP=$EC2_PUBLIC_IP" >> $GITHUB_ENV
          echo "ECR_URI=$ECR_URI" >> $GITHUB_ENV
          echo "PRIVATE_KEY_B64=$PRIVATE_KEY_B64" >> $GITHUB_ENV

      # 7ï¸âƒ£ Decode private key and save to file
      - name: ðŸ” Save SSH Key
        run: |
          echo "$PRIVATE_KEY_B64" | base64 --decode > deploy_key.pem
          chmod 600 deploy_key.pem

      # 8ï¸âƒ£ Log in to ECR
      - name: ðŸ³ Docker Login to ECR
        run: |
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin $ECR_URI

      # 9ï¸âƒ£ Build, tag, and push Docker image
      - name: ðŸ§± Build and Push Docker Image
        run: |
          IMAGE_URI=$ECR_URI:$IMAGE_TAG
          echo "Building image $IMAGE_URI"
          docker build -t $IMAGE_URI .
          docker push $IMAGE_URI
          echo "IMAGE_URI=$IMAGE_URI" >> $GITHUB_ENV

      # ðŸ”Ÿ SSH into EC2 and deploy Docker container
      - name: ðŸš€ Deploy Docker on EC2
        run: |
          ssh -o StrictHostKeyChecking=no -i deploy_key.pem ec2-user@$EC2_PUBLIC_IP << EOF
            sudo yum install -y docker awscli
            sudo systemctl enable docker
            sudo systemctl start docker
            aws ecr get-login-password --region ${{ env.AWS_REGION }} | sudo docker login --username AWS --password-stdin $ECR_URI
            sudo docker stop my-app || true
            sudo docker rm my-app || true
            sudo docker run -d -p 8090:8090 --name my-app --restart always $IMAGE_URI
          EOF

      # 1ï¸âƒ£1ï¸âƒ£ Output live app URL
      - name: ðŸŒ App URL
        run: echo "Your app is live at http://$EC2_PUBLIC_IP:8090"
